import { useState, useCallback } from 'react';
import { MediaFile } from '../types';

export const useWaveformSync = (accessToken: string | null) => {
  const [isSyncing, setIsSyncing] = useState(false);
  
  // CONFIGURATION SYNC: Must match the bucket in your index.js
  const PROXY_BUCKET = "story-graph-proxies";

  /**
   * Fetches the lightweight audio proxy generated by the Transcoder API.
   */
  const fetchAudioProxy = async (filename: string): Promise<AudioBuffer | null> => {
    if (!accessToken) return null;
    
    // FLAT NAMING CONVENTION:
    // We now look directly in proxies/ for the specific suffix
    const baseName = filename.substring(0, filename.lastIndexOf('.'));
    const proxyPath = `proxies/${baseName}_audioproxy.mp4`; 
    const encodedPath = encodeURIComponent(proxyPath);

    console.log(`%c[Waveform] Fetching: ${proxyPath}`, "color: #94a3b8;");

    try {
      // Fetch directly from GCS using the authenticated OAuth token
      const response = await fetch(
        `https://storage.googleapis.com/storage/v1/b/${PROXY_BUCKET}/o/${encodedPath}?alt=media`, 
        { headers: { Authorization: `Bearer ${accessToken}` } }
      );
      
      if (!response.ok) {
         if (response.status === 404) {
           console.warn(`[Waveform] Proxy not found: ${proxyPath}. Ensure Phase 1 finished.`);
         }
         throw new Error(`Proxy fetch failed: ${response.status}`);
      }
      
      const arrayBuffer = await response.arrayBuffer();
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      // decodeAudioData natively supports the AAC/MP4 container
      return await audioContext.decodeAudioData(arrayBuffer);
    } catch (e) {
      console.warn(`[Waveform] Could not load proxy for ${filename}. Check CORS and naming.`);
      return null;
    }
  };

  /**
   * Standard Cross-Correlation Logic
   * Scan small buffers to find the point of highest mathematical similarity.
   */
  const calculateOffset = (masterBuffer: AudioBuffer, slaveBuffer: AudioBuffer) => {
    const masterData = masterBuffer.getChannelData(0);
    const slaveData = slaveBuffer.getChannelData(0);
    const sampleRate = masterBuffer.sampleRate;

    const scanWindow = Math.min(masterData.length, slaveData.length, sampleRate * 60);
    let bestOffset = 0;
    let maxCorrelation = -Infinity;

    // Optimized scanning every 50th sample
    for (let offset = 0; offset < scanWindow; offset += 50) {
      let correlation = 0;
      for (let i = 0; i < 2000; i++) {
        if (masterData[i + offset] && slaveData[i]) {
            correlation += masterData[i + offset] * slaveData[i];
        }
      }
      if (correlation > maxCorrelation) {
        maxCorrelation = correlation;
        bestOffset = offset;
      }
    }

    return bestOffset / sampleRate;
  };

  const syncFiles = useCallback(async (masterFile: MediaFile, slaveFiles: MediaFile[]) => {
    setIsSyncing(true);
    const results: { drive_id: string; offset: number }[] = [];

    try {
      // 1. Get Master Buffer (The audio from the main sound recorder)
      const masterBuffer = await fetchAudioProxy(masterFile.filename);
      
      if (!masterBuffer) {
        console.error("[Waveform] Cannot start sync: Master proxy missing.");
        return [];
      }

      // 2. Compare Slaves (Video files with internal audio) to the Master
      for (const slave of slaveFiles) {
        const slaveBuffer = await fetchAudioProxy(slave.filename);
        
        if (slaveBuffer) {
          const offset = calculateOffset(masterBuffer, slaveBuffer);
          results.push({ drive_id: slave.drive_id, offset });
          console.log(`[Waveform] Match found for ${slave.filename}: ${offset}s offset`);
        }
      }
    } finally {
      setIsSyncing(false);
    }

    return results;
  }, [accessToken]);

  return { syncFiles, isSyncing };
};